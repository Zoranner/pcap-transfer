# 分包协议设计文档

## 概述

本文档描述了pcap-transfer工具的应用层分包协议，用于在UDP传输中处理超过MTU（最大传输单元）的大数据包。

### 设计目标

- 在UDP上对超过MTU的大消息进行应用层分片与重组
- 最小化协议开销，保持低复杂度
- 默认无重传/ACK机制（简单可靠）
- 向后兼容现有未分包的消息

### 协议特点

- 每个UDP报文承载一个"分片"
- 分片 = 协议头(24字节) + 分片负载
- 同一条原始消息被切成多个分片，接收端按message_id重组
- 使用小端序（Little Endian），与程序现有数据处理保持一致

## 协议头格式

### 头部结构（24字节）

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Magic     |   Version     |     Flags     |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
|                                                               |
+                        Message ID (64-bit)                   +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Total Length (32-bit)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Fragment Index (16-bit)     |   Fragment Count (16-bit)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Payload Length (16-bit)     |    Header CRC16 (16-bit)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 字段说明

| 字段名 | 类型 | 字节数 | 字节序 | 说明 |
|--------|------|--------|--------|------|
| magic | u16 | 2 | 小端 | 协议魔数：0x5054 ('P''T'，pcap-transfer标识) |
| version | u8 | 1 | - | 协议版本：1 |
| flags | u8 | 1 | - | 标志位（bit0-1保留，用于后续扩展） |
| message_id | u64 | 8 | 小端 | 消息ID（发送端为每条原始消息生成的唯一标识） |
| total_len | u32 | 4 | 小端 | 原始消息总字节数 |
| frag_index | u16 | 2 | 小端 | 分片序号（从0开始） |
| frag_count | u16 | 2 | 小端 | 总分片数 |
| payload_len | u16 | 2 | 小端 | 当前分片负载长度 |
| header_crc16 | u16 | 2 | 小端 | 协议头CRC16校验（对前22字节计算） |

### 协议常量

```rust
pub const MAGIC: u16 = 0x5054;           // 'P''T'
pub const VERSION: u8 = 1;               // 协议版本
pub const HEADER_SIZE: usize = 24;       // 协议头大小
pub const DEFAULT_MAX_UDP_PAYLOAD: usize = 1400;  // 默认最大UDP负载
```

## 分片与重组机制

### 分片计算

- **配置参数**：`max_udp_payload`（默认1400字节，兼容IPv4/IPv6及额外头部）
- **分片最大负载**：`max_fragment_payload = max_udp_payload - 24`
- **分片数计算**：`frag_count = ceil(total_len / max_fragment_payload)`
- **分片负载**：每片取原始消息的连续切片，最后一片可能小于`max_fragment_payload`

### 发送端流程

1. **消息ID生成**：为每条原始消息生成唯一的u64 ID（随机或单调递增）
2. **分片计算**：根据消息长度和最大分片负载计算分片数
3. **分片封装**：
   - 构造24字节协议头
   - 计算并填充`header_crc16`字段
   - 组装：协议头 + 分片负载
4. **UDP发送**：依次发送所有分片
5. **兼容处理**：未超过MTU的消息也使用此协议（`frag_count=1`）

### 接收端重组流程

1. **分片接收**：接收UDP报文并解析协议头
2. **校验检查**：
   - 验证magic和version字段
   - 验证header_crc16
   - 检查索引范围和长度一致性
3. **重组管理**：
   - 使用键`(source_addr, message_id, version)`维护重组状态
   - 状态包含：total_len, frag_count, received_count, received_bitmap, buffer, start_time
4. **分片存储**：将分片负载拷贝到对应偏移位置
5. **完整性检查**：当`received_count == frag_count`且累计字节达到`total_len`时，输出完整消息
6. **状态清理**：输出完整消息后移除重组状态

### 超时与清理机制

- **超时时间**：默认5秒未完成重组则丢弃
- **DoS保护**：拒绝重组超过阈值（默认10MB）的消息
- **定期清理**：清理超时的重组状态，防止内存泄漏

## 兼容性设计

### 向后兼容

- **识别机制**：接收端首先检查magic字段
- **旧协议处理**：不包含magic的报文按原有逻辑处理
- **平滑迁移**：新旧协议可以共存

### 协议扩展

- **版本控制**：通过version字段支持协议升级
- **标志位预留**：flags字段预留扩展位
- **可选增强**：
  - 原始消息校验：在flags中指示并携带CRC32
  - 流ID支持：添加stream_id字段区分多数据流
  - 简单重传：可选的NAK/重传机制

## 实现要点

### Rust结构定义

```rust
#[derive(Debug, Clone)]
pub struct FragHeader {
    pub magic: u16,         // 0x5054
    pub version: u8,        // 1
    pub flags: u8,          // 0 (预留)
    pub message_id: u64,    // 消息ID
    pub total_len: u32,     // 原始消息总长度
    pub frag_index: u16,    // 分片索引
    pub frag_count: u16,    // 总分片数
    pub payload_len: u16,   // 当前分片负载长度
    pub header_crc16: u16,  // 头部CRC16校验
}

impl FragHeader {
    pub const SIZE: usize = 24;
    pub const MAGIC: u16 = 0x5054;
    pub const VERSION: u8 = 1;
    
    /// 序列化为字节数组（小端序）
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut buf = Vec::with_capacity(Self::SIZE);
        buf.extend_from_slice(&self.magic.to_le_bytes());
        buf.push(self.version);
        buf.push(self.flags);
        buf.extend_from_slice(&self.message_id.to_le_bytes());
        buf.extend_from_slice(&self.total_len.to_le_bytes());
        buf.extend_from_slice(&self.frag_index.to_le_bytes());
        buf.extend_from_slice(&self.frag_count.to_le_bytes());
        buf.extend_from_slice(&self.payload_len.to_le_bytes());
        buf.extend_from_slice(&self.header_crc16.to_le_bytes());
        buf
    }
    
    /// 从字节数组反序列化（小端序）
    pub fn from_bytes(data: &[u8]) -> Result<Self, String> {
        if data.len() < Self::SIZE {
            return Err("Data too short for fragment header".to_string());
        }
        
        let magic = u16::from_le_bytes([data[0], data[1]]);
        let version = data[2];
        let flags = data[3];
        let message_id = u64::from_le_bytes([
            data[4], data[5], data[6], data[7],
            data[8], data[9], data[10], data[11]
        ]);
        let total_len = u32::from_le_bytes([data[12], data[13], data[14], data[15]]);
        let frag_index = u16::from_le_bytes([data[16], data[17]]);
        let frag_count = u16::from_le_bytes([data[18], data[19]]);
        let payload_len = u16::from_le_bytes([data[20], data[21]]);
        let header_crc16 = u16::from_le_bytes([data[22], data[23]]);
        
        Ok(Self {
            magic, version, flags, message_id, total_len,
            frag_index, frag_count, payload_len, header_crc16
        })
    }
}
```

### CRC16计算

使用CRC16-CCITT算法对协议头前22字节进行校验：

```rust
pub fn calculate_crc16(data: &[u8]) -> u16 {
    const CRC16_CCITT_TABLE: [u16; 256] = [
        // CRC16-CCITT查找表
        // ... (省略具体数值)
    ];
    
    let mut crc: u16 = 0xFFFF;
    for &byte in data {
        let index = ((crc >> 8) ^ (byte as u16)) & 0xFF;
        crc = ((crc << 8) ^ CRC16_CCITT_TABLE[index as usize]) & 0xFFFF;
    }
    crc
}
```

### 重组状态管理

```rust
#[derive(Debug)]
pub struct ReassemblyState {
    pub total_len: u32,
    pub frag_count: u16,
    pub received_count: u16,
    pub received_fragments: HashSet<u16>,
    pub buffer: Vec<u8>,
    pub start_time: std::time::Instant,
}

pub type ReassemblyKey = (std::net::SocketAddr, u64, u8); // (source, message_id, version)
pub type ReassemblyMap = HashMap<ReassemblyKey, ReassemblyState>;
```

## 配置参数

### 默认配置

```toml
[fragmentation]
enable_fragmentation = true          # 是否启用分包功能
max_udp_payload = 1400              # 最大UDP负载大小（字节）
reassembly_timeout_ms = 5000        # 重组超时时间（毫秒）
max_message_len = 10485760          # 最大消息长度（10MB）
cleanup_interval_ms = 1000          # 清理间隔（毫秒）
```

### 配置说明

- **enable_fragmentation**：控制是否启用分包功能，关闭时超过MTU的消息会直接发送
- **max_udp_payload**：UDP数据报最大负载，需考虑网络环境和路径MTU
- **reassembly_timeout_ms**：重组超时时间，超时未完成的重组会被丢弃
- **max_message_len**：单个消息最大长度，防止DoS攻击
- **cleanup_interval_ms**：定期清理超时重组状态的间隔

## 性能考虑

### 优化策略

1. **内存预分配**：根据total_len预分配重组缓冲区
2. **批量发送**：发送端可批量发送多个分片减少系统调用
3. **并发重组**：支持多个消息并发重组
4. **快速路径**：未分片消息（frag_count=1）使用快速路径处理

### 监控指标

- 分片发送/接收计数
- 重组成功/失败计数
- 超时重组计数
- 平均重组时间
- 内存使用量

## 错误处理

### 常见错误类型

1. **协议错误**：magic不匹配、version不支持、CRC校验失败
2. **分片错误**：索引越界、长度不一致、重复分片
3. **资源错误**：内存不足、重组表满、消息过大
4. **超时错误**：重组超时、网络中断

### 错误处理策略

- **静默丢弃**：协议错误和格式错误的分片
- **资源保护**：限制并发重组数量和消息大小
- **降级处理**：分包功能异常时回退到直接发送
- **详细日志**：记录错误详情用于调试和监控

## 测试用例

### 单元测试

1. **协议头序列化/反序列化测试**
2. **CRC16计算正确性测试**
3. **分片计算逻辑测试**
4. **重组状态管理测试**

### 集成测试

1. **端到端分包传输测试**
2. **大消息传输测试**
3. **并发传输测试**
4. **异常情况处理测试**

### 性能测试

1. **分包开销测试**
2. **重组性能测试**
3. **内存使用测试**
4. **吞吐量测试**

## 版本历史

### v1.0
- 初始版本
- 基本分包和重组功能
- 小端序支持
- 超时和清理机制
